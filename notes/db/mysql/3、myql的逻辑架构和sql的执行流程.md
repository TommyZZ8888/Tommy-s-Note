msyql逻辑架构
=========

逻辑架构的解析
-------

**逻辑架构图如下（序号代表的是：服务器处理客户端请求的流程）**  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221214758434-1320760982.png)

### 1.1connectors

connectors是指使用不同语言的客户端与mysql server服务器进行交互。

### 1.2连接层

客户端访问mysql服务器之前，需要先建立TCP连接；**当mysql服务器收到客户端的连接请求后会从connections pool线程池中分配一个线程与客户端进行交互**。

*   msyql服务器对TCP传输过来的账号密码做身份认证、权限获取。用户名或者密码不正确，客户端程序结束运行；用户名密码正确，客户端与服务器建立连接，从权限表中读取该用户拥有的权限信息，当执行sql语句时依据读取到的权限信息进行判断。

### 1.3服务层

**1、SQL Interface: SQL接口**

*   **接收用户的SQL命令，并且返回用户需要查询的结果**。比如SELECT ... FROM就是调用SQL Interface
*   MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口

**2、Parser: 解析器**

*   **在解析器中对SQL语句进行语法分析、词法分析**。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句的语法是不合理的。
*   **在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限**。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。

**3、Optimizer: 查询优化器**

*   **SQL语句在语法解析之后、查询之前会使用查询优化器确定SQL语句的执行路径，生成一个执行计划**。
*   这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。

**4、Caches & Buffers： 查询缓存组件**

*   MySQL内部维持着一些Cache和Buffer，比如**Query Cache用来缓存一条SELECT语句的执行结果**，如果能够在其中找到对应的查询结果，**那么就不必再进行查询解析、优化和执行的整个过程了**，直接将结果反馈给客户端。
*   这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。
*   **这个查询缓存可以在不同客户端之间共享**。
*   从MySQL 5.7.20开始，不推荐使用查询缓存，并**在MySQL 8.0中删除** 。

### 1.4引擎层

**插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信**。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。  
**查询默认支持的存储引擎：show engines;（下一个章节对存储引擎有详细的讲解）**  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221230308177-135977349.png)

### 1.5存储层

**所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互。**

mysql中sql的执行流程
--------------

### 2.1sql的执行流程

![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221231132235-1784731524.png)

#### 查询流程：查询缓存-->解析器-->优化器-->执行器-->返回结果

1、查询缓存

*   **查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果**。需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是缓存查询结果。只有相同的查询操作才会命中查询缓存（两个相同查询的概念：请求在任何字符上（如空格、注释、大小写）必须相同，否则不会命中缓存）。
*   **开启缓存机制**：在配置文件中加入：query\_cache\_type=1（0：不开启、1：开启、2：demand按需使用SQL\_CACHE、SQL\_NO\_CACHE）
*   **监控查询命中率**：show status like "%Qcache%";  
    ![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221232323327-1136970123.png)  
    **Qcache\_free\_blocks** :表示**查询缓存中还有多少剩余的blocks**，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。|  
    **Qcache\_free\_memory** :**查询缓存的内存大小**，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。  
    **Qcache\_hits** :表示**有多少次命中缓存**。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。  
    **Qcache\_inserts**:表示**多少次未命中然后插入**，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。  
    **Qcache\_lowmem\_prunes** :该参数**记录有多少条查询因为内存不足而被移除出查询缓存**。通过这个值,用户可以适当的调整缓存大小。  
    **Qcache\_not\_cached** :表示因为query\_cache\_type的设置而**没有被缓存的查询数量**。**Qcache\_queries\_in\_cache**:**当前缓存中缓存的查询数量**。  
    **Qcache\_total\_blocks**:**当前缓存的block数量**。

**2、解析器：在解析器中对 SQL 语句进行语法分析、语义分析，生成一个语法树。**  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221233502352-576074538.png)

**3、优化器：在优化器中会确定SQL语句的执行路径并生成一个执行计划**，比如是根据全表检索，还是根据索引检索等。在查询优化器中，可以分为**逻辑查询优化阶段**（语句的执行顺序）和**物理查询优化阶段**（建立索引）。  
**4、执行器：按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。**

数据库缓冲池（buffer pool）
-------------------

存储引擎将部分内存来作为数据缓冲池，在真正访问页面之前，需要把在磁盘上的页数据缓存到内存中的Buffer Pool 之后才可以访问，这样会减少与磁盘直接进行 I/O 的时间。

### 3.1缓冲池

**数据库缓冲池中存储的是：**  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221235736422-1980106373.png)

### 3.2缓冲池如何读取数据

**1、缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。**  
缓存在数据库中的结构和作用如下图所示：  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220221235936182-1195404917.png)  
2、查看缓冲池的大小：show variables like 'innodb\_buffer\_pool\_size';  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220222000104602-373580130.png)  
3、查看缓冲池的个数：show variables like 'innodb\_buffer\_pool\_instances';  
![image](https://img2022.cnblogs.com/blog/2345397/202202/2345397-20220222000151911-1771348221.png)

本文转自 <https://www.cnblogs.com/worldusemycode/p/15920851.html>，如有侵权，请联系删除。