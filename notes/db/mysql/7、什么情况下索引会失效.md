索引优化
====

索引失效（已经创建索引，但是不能使用索引）
---------------------

### 1.1全值匹配我最爱

当查询结果一样的前提下：查询语句不变，where语句中匹配的索引字段key\_len值越大查询就越快。

### 1.2按照主键自增的插入数据

我们自定义的主键列id拥有AUTO\_INCREMENT属性，在插入记录时存储引擎会自动为我们填入自增的主键值。**这样的主键占用空间小，顺序写入，减少页分裂。**

### 1.3最左前缀法则

如果索引了多列，要遵守最左前缀法则（查询必须从索引的最左前列开始否则会出现索引不能匹配上；查询时不能跳过索引中的列，这种情况可以匹配上索引，但是只能匹配部分字段）  
![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313180156502-1838831513.png)

### 1.4不在索引列上做任何操作（计算、函数、自动或者手动类型转换），否则会导致索引失效而转向全表扫描

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313180313384-940749177.png)

### 1.5类型转换导致索引失效

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313180426062-217438725.png)

### 1.6范围条件右边的列索引失效（自己不会失效）

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313180745063-66248653.png)

### 1.7mysql不能对索引列使用不等于（!=或者<>），否则会导致索引失效导致全表扫描

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313181000800-1639471795.png)

### 1.8is null可以使用索引，is not null无法使用索引

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313181108746-2120057350.png)

### 1.9使用like进行模糊查询时，百分号只能放在右边，否则会出现全表扫描

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313181212961-2146277996.png)

`如果想要使用'%July%'进行模糊查询，但是还不想索引失效（type会变成all），就要使用覆盖索引（type会变为index）（select查询字段的数量包含于（复合索引的字段的数量+主键ID））`  
![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313182420747-1313339241.png)

### 1.10 OR前后存在非索引的列，索引失效

![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313181822169-1924482577.png)

### 1.11尽量使用覆盖索引（select查询字段的数量包含于（复合索引的字段的数量+主键ID））,减少使用select \* 查询数据

*   using index：覆盖索引扫描，表示查询时在索引树中就可以找到所需要的数据，不需要扫描数据文件。  
    ![image](https://img2022.cnblogs.com/blog/2345397/202203/2345397-20220313182943795-1887783333.png)

### 1.12数据库和表的字符集统一使用utf8mb4

统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。**不同的字符集进行比较前需要进行转换会造成索引失效。**

本文转自 <https://www.cnblogs.com/worldusemycode/p/15954836.html>，如有侵权，请联系删除。